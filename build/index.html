<html><head><title>View.js</title><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css"/><link rel="stylesheet" href="/public/index.css"/><script type="text/javascript" src="//use.typekit.net/phm0nvf.js"></script><script>try{Typekit.load();}catch(e){}</script><script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="sidebar"><h1>Docs</h1><ul><li class="category"><a href="/">Overview</a></li><li class="category"><a href="/">Getting Started</a></li></ul></div><div class="container"><div class="wrapper"><section class="top"><a href="https://github.com/viewjs/view">Github</a></section><header><h1 class="title"><a href="">View.js</a></h1></header><section class="content"><div><p>View.js is a primitive low-level view layer. The vision starts off from first-principles: Taking an idea and deconstructing it into it&#39;s most atomic pieces.</p>
<p>The current landscape for client-side &quot;frameworks&quot; is extremely fragmented, monolithic, inconsistent &mdash; broken. We need to fix this.</p>
<h2 id="modularize-everything">Modularize Everything</h2>
<p>We need to move away from frameworks entirely. We need to move towards libraries. Libraries allow you to easily swap functionality by introducing an alternative module.</p>
<p>There&#39;s a problem with this approach. Things are too chaotic, non-composable, and fragmented. That&#39;s why you need to think in first-principles, and find an acceptable base.</p>
<p>View.js is just that. A single piece in the puzzle of the client-side (and server-side) landscape. View.js handles bringing the building block for reactive views and templates that are extremely extensible.</p>
<h2 id="standardize">Standardize</h2>
<p>View.js uses <a href="https://github.com/component/component">component(1)</a> as it&#39;s foundation. Component(1) is an opinionated client-side package manager and build tool. Unlike ad-hoc tools like Bower, where it leaves the building process to the end-user, component(1) handles this completely for you, because of it&#39;s process.</p>
<p>View.js is split up in several small, unix-like components. Each of these components can be used (<em>and tested</em>) in isolation. This allows an incredible amount of code re-use and flexibility.</p>
<h2 id="distribution-build-system">Distribution &amp; Build System</h2>
<p>Everything is run through component(1). This allows a <em>standard</em> and <em>consistent</em> experience.</p>
<p>Fetching a button UI view component is extremely easy.</p>
<pre><code class="lang-bash">component install ui/button --save
</code></pre>
<p>Wait, you can also build your app if you include another step:</p>
<pre><code class="lang-bash">component build
</code></pre>
</div></section></div></div></body></html>